"""
Code Validator - Validates agent-generated code before execution.

This module provides syntax validation, static analysis, and security checks
for code generated by agents.

Phase 1: Enhanced with AST-based security rules engine.
"""
import ast
import re
from typing import Dict, Any, List, Optional, Tuple

# Import security rules engine
try:
    from security.rules import SecurityRuleEngine, SecurityLevel
except ImportError:
    # Fallback if security module not available
    SecurityRuleEngine = None
    SecurityLevel = None


class CodeValidator:
    """Validates Python code for syntax, safety, and correctness.
    
    Phase 1: Enhanced with AST-based security rules engine.
    """
    
    def __init__(self, use_security_rules: bool = True):
        """Initialize code validator.
        
        Args:
            use_security_rules: Whether to use enhanced security rules engine
        """
        self.use_security_rules = use_security_rules and SecurityRuleEngine is not None
        
        if self.use_security_rules:
            self.security_engine = SecurityRuleEngine()
        else:
            # Fallback to legacy patterns
            self.dangerous_patterns = [
                (r'\bos\.system\s*\(', "os.system() - dangerous system call"),
                (r'\bsubprocess\.(run|call|Popen)\s*\(', "subprocess - dangerous subprocess execution"),
                (r'\beval\s*\(', "eval() - code injection risk"),
                (r'\bexec\s*\(', "exec() - code injection risk"),
                (r'\b__import__\s*\(', "__import__() - dynamic import risk"),
                (r'\bopen\s*\([^)]*[\'"]w', "File write operation"),
                (r'\bopen\s*\([^)]*[\'"]a', "File append operation"),
            ]
    
    def validate_syntax(self, code: str) -> Tuple[bool, Optional[str]]:
        """Validate Python syntax.
        
        Returns:
            (is_valid, error_message)
        """
        try:
            ast.parse(code)
            return True, None
        except SyntaxError as e:
            error_msg = f"Syntax error at line {e.lineno}: {e.msg}"
            if e.text:
                error_msg += f"\n  {e.text.strip()}"
                if e.offset:
                    error_msg += f"\n  {' ' * (e.offset - 1)}^"
            return False, error_msg
        except Exception as e:
            return False, f"Parse error: {str(e)}"
    
    def check_dangerous_patterns(self, code: str) -> List[str]:
        """Check for potentially dangerous code patterns.
        
        Returns:
            List of warnings about dangerous patterns found
        """
        warnings = []
        for pattern, description in self.dangerous_patterns:
            # Skip exec() check if it's in a comment or string literal
            if pattern == r'\bexec\s*\(':
                # Check if exec() is actually in executable code, not in comments/strings
                try:
                    tree = ast.parse(code)
                    for node in ast.walk(tree):
                        if isinstance(node, ast.Call):
                            if isinstance(node.func, ast.Name) and node.func.id == 'exec':
                                warnings.append(description)
                                break
                except:
                    # Fallback to regex if parsing fails
                    if re.search(pattern, code):
                        warnings.append(description)
            else:
                if re.search(pattern, code):
                    warnings.append(description)
        return warnings
    
    def check_async_usage(self, code: str) -> List[str]:
        """Check for async/await usage issues.
        
        Returns:
            List of warnings about async issues
        """
        warnings = []
        
        # Check for async functions without await
        async_func_pattern = r'async\s+def\s+\w+\s*\([^)]*\):'
        if re.search(async_func_pattern, code):
            # Check if there are any await calls
            if 'await' not in code:
                warnings.append("Async function defined but no 'await' found - may be missing await calls")
        
        # Check for await without async context
        if 'await' in code and 'async def' not in code:
            # This is okay if code is wrapped in async function
            pass
        
        # Check for common async mistakes
        if 'await' in code:
            # Check for await on non-async calls (basic check)
            lines = code.split('\n')
            for i, line in enumerate(lines, 1):
                if 'await' in line and 'get_transcript' in line or 'update_crm' in line:
                    # These should be awaited, so this is fine
                    pass
        
        return warnings
    
    def check_imports(self, code: str, allowed_imports: List[str] = None) -> List[str]:
        """Check for problematic imports.
        
        Args:
            code: Code to check
            allowed_imports: List of allowed import patterns
        
        Returns:
            List of warnings about imports
        """
        warnings = []
        # Standard library modules that are always allowed
        stdlib_modules = ['os', 'sys', 'io', 're', 'datetime', 'time', 'json', 'pathlib', 
                        'collections', 'itertools', 'functools', 'asyncio', 'typing',
                        'math', 'random', 'string', 'csv', 'urllib', 'http']
        
        allowed_imports = allowed_imports or [
            'servers', 'mcp', 'mcp.types', 'mcp_client', 
            'asyncio', 'json', 'pathlib', 'typing',
            'os', 'sys', 'io', 're', 'datetime', 'time',
            'collections', 'itertools', 'functools'
        ]
        
        # Extract import statements
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        import_name = alias.name.split('.')[0]  # Get base module name
                        # Check if it's in allowed imports or standard library
                        is_allowed = (any(allowed == import_name or import_name.startswith(allowed + '.') 
                                        for allowed in allowed_imports) or
                                     import_name in stdlib_modules)
                        if not is_allowed:
                            warnings.append(f"Unusual import: {alias.name}")
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        module_base = node.module.split('.')[0]
                        # Check if it's in allowed imports or standard library
                        is_allowed = (any(allowed == module_base or module_base.startswith(allowed + '.') 
                                        for allowed in allowed_imports) or
                                     module_base in stdlib_modules)
                        if not is_allowed:
                            warnings.append(f"Unusual import from: {node.module}")
        except:
            # If we can't parse, skip import checking
            pass
        
        return warnings
    
    def check_infinite_loops(self, code: str) -> List[str]:
        """Check for potential infinite loops.
        
        Returns:
            List of warnings about infinite loops
        """
        warnings = []
        
        # Check for while True without break
        if 'while True:' in code:
            # Count breaks in the same scope (simplified check)
            lines = code.split('\n')
            in_while = False
            break_found = False
            for line in lines:
                if 'while True:' in line:
                    in_while = True
                    break_found = False
                elif in_while:
                    if 'break' in line:
                        break_found = True
                    elif line.strip() and not line.strip().startswith('#'):
                        # Check if we're still in the while block
                        if line.strip().startswith(' ') or line.strip().startswith('\t'):
                            continue
                        else:
                            # Out of while block
                            if not break_found:
                                warnings.append("Potential infinite loop: 'while True:' without 'break'")
                            in_while = False
        
        return warnings
    
    def check_unused_functions(self, code: str) -> List[str]:
        """Check if functions are defined but never called or result not set.
        
        Returns:
            List of warnings about unused functions
        """
        warnings = []
        
        try:
            tree = ast.parse(code)
            defined_functions = []
            function_calls = []
            has_result_assignment = False
            
            # Find all function definitions
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    defined_functions.append(node.name)
                elif isinstance(node, ast.Call):
                    if isinstance(node.func, ast.Name):
                        function_calls.append(node.func.id)
                    elif isinstance(node.func, ast.Attribute):
                        function_calls.append(node.func.attr)
                elif isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name) and target.id == '_result':
                            has_result_assignment = True
            
            # Check if functions are defined but not called
            for func_name in defined_functions:
                if func_name not in function_calls:
                    # Function defined but never called
                    # Check if _result is set - if not, this is a problem
                    if not has_result_assignment:
                        warnings.append(
                            f"Function '{func_name}' is defined but never called, and '_result' is not set. "
                            f"Call the function and assign to _result: _result = {func_name}()"
                        )
        except:
            # If parsing fails, skip this check
            pass
        
        return warnings
    
    def validate(self, code: str) -> Dict[str, Any]:
        """Comprehensive code validation.
        
        Phase 1: Enhanced with AST-based security rules.
        
        Returns:
            Dict with validation results
        """
        results = {
            "valid": False,
            "syntax_valid": False,
            "warnings": [],
            "errors": [],
            "safe": True,
            "blocked": False,  # New: indicates if code is blocked by security rules
            "security_violations": []  # New: detailed security violations
        }
        
        # 1. Syntax validation
        syntax_valid, syntax_error = self.validate_syntax(code)
        results["syntax_valid"] = syntax_valid
        if not syntax_valid:
            results["errors"].append(syntax_error)
            results["blocked"] = True
            return results
        
        # 2. Enhanced security rules (Phase 1)
        if self.use_security_rules:
            security_result = self.security_engine.validate(code)
            results["blocked"] = security_result["blocked"]
            results["safe"] = not security_result["blocked"]
            
            # Convert security violations to warnings/errors
            for violation in security_result["blocking_violations"]:
                results["errors"].append(f"[{violation.rule_name}] {violation.message}")
                if violation.line_number:
                    results["errors"][-1] += f" (line {violation.line_number})"
            
            for violation in security_result["warnings"]:
                results["warnings"].append(f"[{violation.rule_name}] {violation.message}")
                if violation.line_number:
                    results["warnings"][-1] += f" (line {violation.line_number})"
            
            results["security_violations"] = security_result["violations"]
        else:
            # Fallback to legacy validation
            dangerous = self.check_dangerous_patterns(code)
            if dangerous:
                results["warnings"].extend(dangerous)
                results["safe"] = False
        
        # 3. Async usage (legacy checks, still useful)
        async_issues = self.check_async_usage(code)
        results["warnings"].extend(async_issues)
        
        # 4. Import checking (legacy, now handled by security rules if enabled)
        if not self.use_security_rules:
            import_issues = self.check_imports(code)
            results["warnings"].extend(import_issues)
        
        # 5. Infinite loops (legacy, now handled by security rules if enabled)
        if not self.use_security_rules:
            loop_issues = self.check_infinite_loops(code)
            results["warnings"].extend(loop_issues)
        
        # 6. Check for unused functions (functions defined but not called, and _result not set)
        unused_func_issues = self.check_unused_functions(code)
        results["warnings"].extend(unused_func_issues)
        
        # Overall validation
        results["valid"] = syntax_valid and results["safe"] and not results["blocked"]
        
        return results


def validate_code(code: str) -> Dict[str, Any]:
    """Convenience function for code validation.
    
    Args:
        code: Python code to validate
    
    Returns:
        Validation results dict
    """
    validator = CodeValidator()
    return validator.validate(code)

